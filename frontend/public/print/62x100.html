<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="utf-8" />
    <title>Etikett 62x100</title>
    <!-- TODO(agent): Keep 62x100 layout aligned with backend PDF sizing. -->
    <!-- TODO(agentic-printing): Capture printer margin telemetry to keep single-page sizing reliable across devices. -->
    <!-- TODO(agentic-printing): Support server-injected payloads so backend print flows reuse this template. -->
    <style>
      @page {
        size: 62mm 100mm;
        margin: 0;
      }
      :root {
        color-scheme: only light;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: grid;
        place-items: center;
        background: #f3f4f6;
        font-family: 'Helvetica Neue', Arial, sans-serif;
        width: 62mm;
        height: 100mm;
      }
      .label {
        box-sizing: border-box;
        width: 62mm;
        height: 100mm;
        padding: 4mm;
        background: #fff;
        border: 1px solid #e5e7eb;
        border-radius: 4mm;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: space-between;
        gap: 4mm;
        box-shadow: 0 6px 18px rgba(0, 0, 0, 0.12);
      }
      .qr {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
      }
      .qr img,
      .qr canvas {
        width: 60mm;
        height: 60mm;
        max-width: 60mm;
        max-height: 60mm;
        aspect-ratio: 1 / 1;
        image-rendering: pixelated;
      }
      .caption {
        width: 100%;
        text-align: center;
        font-size: 11pt;
        color: #111827;
        line-height: 1.25;
        letter-spacing: 0.25px;
        white-space: pre-line;
      }
      .error {
        margin: 16px;
        padding: 12px 14px;
        border-radius: 6px;
        background: #fee2e2;
        color: #b91c1c;
        font-size: 12pt;
        max-width: 420px;
      }
      @media print {
        body {
          background: none;
          width: 62mm;
          height: 100mm;
          min-height: 100mm;
        }
        .label {
          box-shadow: none;
          border-color: transparent;
          page-break-inside: avoid;
        }
        .error {
          display: none !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="label" id="label" hidden>
      <div class="qr">
        <img id="qrImage" alt="QR-Code" href="testQR.png" />
        <canvas id="qrCanvas" hidden></canvas>
      </div>
      <div class="caption" id="caption">I-201125-0XYZ</div>
    </div>
    <div class="error" id="error" hidden></div>
    <script>
      (function init() {
        const state = { payload: null };
        const labelEl = document.getElementById('label');
        const qrImage = document.getElementById('qrImage');
        const qrCanvas = document.getElementById('qrCanvas');
        const captionEl = document.getElementById('caption');
        const errorEl = document.getElementById('error');

        function drawMatrix(modules, margin = 0) {
          if (!qrCanvas || !Array.isArray(modules) || modules.length === 0) return false;
          try {
            const size = modules.length;
            const pixelSize = 720;
            const available = pixelSize - margin * 2;
            const scale = Math.floor(available / size);
            const offset = Math.floor((pixelSize - size * scale) / 2);
            const ctx = qrCanvas.getContext('2d');
            if (!ctx) return false;
            qrCanvas.width = pixelSize;
            qrCanvas.height = pixelSize;
            ctx.clearRect(0, 0, pixelSize, pixelSize);
            ctx.fillStyle = '#111827';
            modules.forEach((row, y) => {
              row.forEach((cell, x) => {
                if (cell) ctx.fillRect(offset + x * scale, offset + y * scale, scale, scale);
              });
            });
            qrCanvas.hidden = false;
            return true;
          } catch (err) {
            console.error('Failed to draw QR matrix on canvas', err);
            return false;
          }
        }

        function showError(message) {
          if (!errorEl) return;
          errorEl.textContent = message;
          errorEl.hidden = false;
          if (labelEl) labelEl.hidden = true;
        }

        function resolveLabel(payload) {
          if (!payload || typeof payload !== 'object') return '—';
          const isBox = payload.type === 'box';
          const labelText = typeof payload.labelText === 'string' && payload.labelText.trim()
            ? payload.labelText.trim()
            : null;
          if (labelText) return labelText;
          if (isBox) {
            return payload.id || payload.boxId || payload.BoxId || '—';
          }
          return payload.materialNumber || payload.Artikelnummer || payload.articleNumber || payload.id || '—';
        }

        function render(payload) {
          if (!payload || typeof payload !== 'object') {
            showError('Kein gültiger Payload vorhanden.');
            return;
          }
          try {
            const labelText = resolveLabel(payload);
            const captionPrefix = payload.type === 'box' ? 'BoxId' : 'Artikelnummer';
            if (captionEl) captionEl.textContent = `${captionPrefix} ${labelText}`;
            if (labelEl) labelEl.hidden = false;

            const hasDataUri = typeof payload.qrDataUri === 'string' && payload.qrDataUri.startsWith('data:image/');
            if (qrImage) {
              if (hasDataUri) {
                qrImage.src = payload.qrDataUri;
                qrImage.hidden = false;
              } else {
                qrImage.hidden = true;
              }
            }

            let fallbackRendered = false;
            if (!hasDataUri && Array.isArray(payload.qrModules)) {
              fallbackRendered = drawMatrix(payload.qrModules, payload.qrMargin);
            }
            if (qrCanvas) {
              qrCanvas.hidden = hasDataUri ? true : !fallbackRendered;
            }
            if (!hasDataUri && !fallbackRendered) {
              console.warn('QR fallback rendering skipped: no modules available.');
            }

            state.payload = payload;
          } catch (err) {
            console.error('Render error in 62x100 label', err);
            showError('Vorlage konnte nicht gerendert werden.');
          }
        }

        function tryFromStorage(key) {
          if (!key) return false;
          try {
            const raw = sessionStorage.getItem(key);
            if (!raw) {
              showError('Kein zwischengespeicherter Payload gefunden.');
              return true;
            }
            const payload = JSON.parse(raw);
            sessionStorage.removeItem(key);
            render(payload);
            return true;
          } catch (err) {
            console.error('Failed to load payload from storage', err);
            showError('Payload konnte nicht gelesen werden.');
            return true;
          }
        }

        function tryInlinePayload() {
          const inlinePayload = window.__LABEL_PAYLOAD__;
          if (!inlinePayload) return false;
          try {
            render(inlinePayload);
            return true;
          } catch (err) {
            console.error('Failed to render inline payload', err);
            showError('Eingebettete Druckdaten konnten nicht gelesen werden.');
            return true;
          }
        }

        function handleMessage(event) {
          if (event.origin && event.origin !== window.location.origin) {
            console.warn('Ignoring message from unexpected origin', event.origin);
            return;
          }
          try {
            const data = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
            if (data && data.payload) {
              render(data.payload);
            }
          } catch (err) {
            console.error('Failed to parse postMessage payload', err);
            showError('Übertragene Daten ungültig.');
          }
        }

        window.addEventListener('message', handleMessage, { once: true });

        const params = new URLSearchParams(window.location.search);
        const key = params.get('key');
        if (!tryInlinePayload() && !tryFromStorage(key)) {
          console.warn('Warte auf Payload via postMessage…');
        }
      })();
    </script>
  </body>
</html>
